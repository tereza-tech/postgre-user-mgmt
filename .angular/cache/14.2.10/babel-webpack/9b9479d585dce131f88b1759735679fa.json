{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\n\nexport var REALTIME_LISTEN_TYPES;\n\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\n\nexport var REALTIME_SUBSCRIBE_STATES;\n\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n **/\n\n\nexport default class RealtimeChannel {\n  constructor(\n  /** Topic name can be any string. */\n  topic, params = {\n    config: {}\n  }, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n\n      this.socket._remove(this);\n    });\n\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n\n    this.presence = new RealtimePresence(this);\n  }\n  /** Subscribe registers your client with the server */\n\n\n  subscribe(callback, timeout = this.timeout) {\n    var _a, _b;\n\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n    } else {\n      const {\n        config: {\n          broadcast,\n          presence\n        }\n      } = this.params;\n\n      this._onError(e => callback && callback('CHANNEL_ERROR', e));\n\n      this._onClose(() => callback && callback('CLOSED'));\n\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : []\n      };\n\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken;\n      }\n\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n\n      this._rejoin(timeout);\n\n      this.joinPush.receive('ok', ({\n        postgres_changes: serverPostgresFilters\n      }) => {\n        var _a;\n\n        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);\n\n        if (serverPostgresFilters === undefined) {\n          callback && callback('SUBSCRIBED');\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback('SUBSCRIBED');\n          return;\n        }\n      }).receive('error', error => {\n        callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback && callback('TIMED_OUT');\n        return;\n      });\n    }\n\n    return this;\n  }\n\n  presenceState() {\n    return this.presence.state;\n  }\n\n  track(payload, opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: 'presence',\n        event: 'track',\n        payload\n      }, opts.timeout || this.timeout);\n    });\n  }\n\n  untrack(opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this.send({\n        type: 'presence',\n        event: 'untrack'\n      }, opts);\n    });\n  }\n\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n\n  send(payload, opts = {}) {\n    return new Promise(resolve => {\n      var _a, _b, _c;\n\n      const push = this._push(payload.type, payload, opts.timeout || this.timeout);\n\n      if (push.rateLimited) {\n        resolve('rate limited');\n      }\n\n      if (payload.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n        resolve('ok');\n      }\n\n      push.receive('ok', () => resolve('ok'));\n      push.receive('timeout', () => resolve('timed out'));\n    });\n  }\n\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n\n\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n\n    this.rejoinTimer.reset(); // Destroy joinPush to avoid connection timeouts during unscription phase\n\n    this.joinPush.destroy();\n    return new Promise(resolve => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    });\n  }\n  /** @internal */\n\n\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n\n    let pushEvent = new Push(this, event, payload, timeout);\n\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n\n    return pushEvent;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n\n\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n\n\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n\n\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n\n\n  _trigger(type, payload, ref) {\n    var _a, _b;\n\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n\n\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n\n\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n\n\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n\n\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n\n\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n\n\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n\n    return this;\n  }\n  /** @internal */\n\n\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n      var _a;\n\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  /** @internal */\n\n\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /** @internal */\n\n\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n\n\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n\n\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n\n\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n\n\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n\n    this.socket._leaveOpenTopic(this.topic);\n\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n\n\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n\n    return records;\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","Transformers","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","RealtimeChannel","constructor","topic","params","config","socket","bindings","state","closed","joinedOnce","pushBuffer","Object","assign","broadcast","ack","self","presence","key","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","subscribe","callback","_a","_b","accessTokenPayload","postgres_changes","map","r","filter","accessToken","access_token","updateJoinPayload","_rejoin","serverPostgresFilters","setAuth","undefined","clientPostgresBindings","bindingsLen","length","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","values","presenceState","track","opts","type","untrack","on","_c","_push","rateLimited","updatePayload","leaving","onClose","close","destroy","leavePush","leave","_canPush","trigger","startTimeout","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","_d","_e","_f","bindId","bindEvent","ids","data","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","isConnected","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["/home/runner/Usrmgmt/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n **/\nexport default class RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '' },\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence(this);\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b;\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            const { config: { broadcast, presence }, } = this.params;\n            this._onError((e) => callback && callback('CHANNEL_ERROR', e));\n            this._onClose(() => callback && callback('CLOSED'));\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence,\n                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],\n            };\n            if (this.socket.accessToken) {\n                accessTokenPayload.access_token = this.socket.accessToken;\n            }\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', ({ postgres_changes: serverPostgresFilters, }) => {\n                var _a;\n                this.socket.accessToken &&\n                    this.socket.setAuth(this.socket.accessToken);\n                if (serverPostgresFilters === undefined) {\n                    callback && callback('SUBSCRIBED');\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            callback &&\n                                callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback('SUBSCRIBED');\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                callback &&\n                    callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback && callback('TIMED_OUT');\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    track(payload, opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.send({\n                type: 'presence',\n                event: 'track',\n                payload,\n            }, opts.timeout || this.timeout);\n        });\n    }\n    untrack(opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.send({\n                type: 'presence',\n                event: 'untrack',\n            }, opts);\n        });\n    }\n    on(type, filter, callback) {\n        return this._on(type, filter, callback);\n    }\n    send(payload, opts = {}) {\n        return new Promise((resolve) => {\n            var _a, _b, _c;\n            const push = this._push(payload.type, payload, opts.timeout || this.timeout);\n            if (push.rateLimited) {\n                resolve('rate limited');\n            }\n            if (payload.type === 'broadcast' &&\n                !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                resolve('ok');\n            }\n            push.receive('ok', () => resolve('ok'));\n            push.receive('timeout', () => resolve('timed out'));\n        });\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.rejoinTimer.reset();\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        return new Promise((resolve) => {\n            const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        });\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return (bindEvent === '*' ||\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n            var _a;\n            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                RealtimeChannel.isEqual(bind.filter, filter));\n        });\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}