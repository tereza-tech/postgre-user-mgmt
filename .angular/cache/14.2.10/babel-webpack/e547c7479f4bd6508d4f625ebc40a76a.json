{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\n\nconst noop = () => {};\n\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint, options) {\n    var _a;\n\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n      this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n\n\n  connect() {\n    if (this.conn) {\n      return;\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n\n      this.conn.onopen = () => this._onConnOpen();\n\n      this.conn.onerror = error => this._onConnError(error);\n\n      this.conn.onmessage = event => this._onConnMessage(event);\n\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n\n\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n\n\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n\n      this.conn = null; // remove open handles\n\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n\n  getChannels() {\n    return this.channels;\n  }\n\n  removeChannel(channel) {\n    return channel.unsubscribe().then(status => {\n      if (this.channels.length === 0) {\n        this.disconnect();\n      }\n\n      return status;\n    });\n  }\n\n  removeAllChannels() {\n    return Promise.all(this.channels.map(channel => channel.unsubscribe())).then(values => {\n      this.disconnect();\n      return values;\n    });\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n\n\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n\n\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Retuns `true` is the connection is open.\n   */\n\n\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n\n  channel(topic, params = {\n    config: {}\n  }) {\n    if (!this.isConnected()) {\n      this.connect();\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n\n\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n\n    let callback = () => {\n      this.encode(data, result => {\n        var _a;\n\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)();\n\n        if (isThrottled) {\n          return 'rate limited';\n        }\n      } else {\n        callback();\n      }\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n\n\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach(channel => {\n      token && channel.updateJoinPayload({\n        access_token: token\n      });\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, {\n          access_token: token\n        });\n      }\n    });\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n\n\n  _makeRef() {\n    let newRef = this.ref + 1;\n\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n\n    return this.ref.toString();\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n\n\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n\n\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());\n  }\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n\n\n  _endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /** @internal */\n\n\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n\n\n  _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`);\n\n    this._flushSendBuffer();\n\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n\n\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n\n    this._triggerChanError();\n\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n\n\n  _onConnError(error) {\n    this.log('transport', error.message);\n\n    this._triggerChanError();\n\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n\n\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n\n\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  /** @internal */\n\n\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /** @internal */\n\n\n  _sendHeartbeat() {\n    var _a;\n\n    if (!this.isConnected()) {\n      return;\n    }\n\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n  /** @internal */\n\n\n  _throttle(callback, eventsPerSecondLimit = this.eventsPerSecondLimitMs) {\n    return () => {\n      if (this.inThrottle) return true;\n      callback();\n      this.inThrottle = true;\n      setTimeout(() => {\n        this.inThrottle = false;\n      }, eventsPerSecondLimit);\n      return false;\n    };\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","RealtimeClient","constructor","endPoint","options","_a","accessToken","channels","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","eventsPerSecondLimitMs","inThrottle","websocket","Object","assign","eventsPerSecond","Math","floor","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","disconnect","connect","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","_onConnMessage","onclose","_onConnClose","code","reason","clearInterval","reset","getChannels","removeChannel","channel","unsubscribe","status","length","removeAllChannels","all","map","values","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","config","chan","push","send","includes","isThrottled","_throttle","setAuth","token","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","_makeRef","newRef","toString","_leaveOpenTopic","dupChannel","find","c","_isJoining","_remove","filter","_joinRef","_appendParams","vsn","rawMessage","type","_isMember","_trigger","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","eventsPerSecondLimit","setTimeout"],"sources":["/home/runner/Usrmgmt/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE, } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessToken = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.transport = w3cwebsocket;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.eventsPerSecondLimitMs = 100;\n        this.inThrottle = false;\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.transport)\n            this.transport = options.transport;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n        if (eventsPerSecond)\n            this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n            this.disconnect();\n            this.connect();\n        }), this.reconnectAfterMs);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    getChannels() {\n        return this.channels;\n    }\n    removeChannel(channel) {\n        return channel.unsubscribe().then((status) => {\n            if (this.channels.length === 0) {\n                this.disconnect();\n            }\n            return status;\n        });\n    }\n    removeAllChannels() {\n        return Promise.all(this.channels.map((channel) => channel.unsubscribe())).then((values) => {\n            this.disconnect();\n            return values;\n        });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overriden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        if (!this.isConnected()) {\n            this.connect();\n        }\n        const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        let callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n                const isThrottled = this._throttle(callback)();\n                if (isThrottled) {\n                    return 'rate limited';\n                }\n            }\n            else {\n                callback();\n            }\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n    setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel) => {\n            token && channel.updateJoinPayload({ access_token: token });\n            if (channel.joinedOnce && channel._isJoined()) {\n                channel._push(CHANNEL_EVENTS.access_token, { access_token: token });\n            }\n        });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n    _endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if ((ref && ref === this.pendingHeartbeatRef) ||\n                event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    _onConnOpen() {\n        this.log('transport', `connected to ${this._endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    /** @internal */\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /** @internal */\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth(this.accessToken);\n    }\n    /** @internal */\n    _throttle(callback, eventsPerSecondLimit = this.eventsPerSecondLimitMs) {\n        return () => {\n            if (this.inThrottle)\n                return true;\n            callback();\n            this.inThrottle = true;\n            setTimeout(() => {\n                this.inThrottle = false;\n            }, eventsPerSecondLimit);\n            return false;\n        };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}