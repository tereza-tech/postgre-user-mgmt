{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, NETWORK_FAILURE, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n\n\n  initialize() {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize();\n    }\n\n    return this.initializePromise;\n  }\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n\n\n  _initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.initializePromise) {\n        return this.initializePromise;\n      }\n\n      try {\n        if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n          const {\n            data,\n            error\n          } = yield this._getSessionFromUrl();\n\n          if (error) {\n            // failed login attempt via url,\n            // remove old session as in verifyOtp, signUp and signInWith*\n            yield this._removeSession();\n            return {\n              error\n            };\n          }\n\n          const {\n            session,\n            redirectType\n          } = data;\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n\n          if (redirectType === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n          }\n\n          return {\n            error: null\n          };\n        } // no login attempt via callback url try to recover session from storage\n\n\n        yield this._recoverAndRefresh();\n        return {\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            error\n          };\n        }\n\n        return {\n          error: new AuthUnknownError('Unexpected error during initialization', error)\n        };\n      } finally {\n        this._handleVisibilityChange();\n      }\n    });\n  }\n  /**\n   * Creates a new user.\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n\n\n  signUp(credentials) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n\n        if (error || !data) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   */\n\n\n  signInWithPassword(credentials) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        let res;\n\n        if ('email' in credentials) {\n          const {\n            email,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              email,\n              password,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else if ('phone' in credentials) {\n          const {\n            phone,\n            password,\n            options\n          } = credentials;\n          res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n            headers: this.headers,\n            body: {\n              phone,\n              password,\n              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            xform: _sessionResponse\n          });\n        } else {\n          throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n        }\n\n        const {\n          data,\n          error\n        } = res;\n        if (error || !data) return {\n          data: {\n            user: null,\n            session: null\n          },\n          error\n        };\n\n        if (data.session) {\n          yield this._saveSession(data.session);\n\n          this._notifyAllSubscribers('SIGNED_IN', data.session);\n        }\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in an existing user via a third-party provider.\n   */\n\n\n  signInWithOAuth(credentials) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._removeSession();\n      return this._handleProviderSignIn(credentials.provider, {\n        redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n      });\n    });\n  }\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   */\n\n\n  signInWithOtp(credentials) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n\n        if ('email' in credentials) {\n          const {\n            email,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              email,\n              data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            },\n            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        if ('phone' in credentials) {\n          const {\n            phone,\n            options\n          } = credentials;\n          const {\n            error\n          } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n            headers: this.headers,\n            body: {\n              phone,\n              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n              gotrue_meta_security: {\n                captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n              }\n            }\n          });\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n\n\n  verifyOtp(params) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n          headers: this.headers,\n          body: Object.assign(Object.assign({}, params), {\n            gotrue_meta_security: {\n              captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n            }\n          }),\n          redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n          xform: _sessionResponse\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        const session = data.session;\n        const user = data.user;\n\n        if (session === null || session === void 0 ? void 0 : session.access_token) {\n          yield this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN', session);\n        }\n\n        return {\n          data: {\n            user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   *\n   * This API is experimental and availability is conditional on correct\n   * settings on the Auth service.\n   *\n   * @experimental\n   */\n\n\n  signInWithSSO(params) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this._removeSession();\n        return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n            provider_id: params.providerId\n          } : null), 'domain' in params ? {\n            domain: params.domain\n          } : null), {\n            redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n          }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n            gotrue_meta_security: {\n              captcha_token: params.options.captchaToken\n            }\n          } : null), {\n            skip_http_redirect: true\n          }),\n          headers: this.headers,\n          xform: _ssoResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n\n\n  getSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // make sure we've read the session from the url if there is one\n      // save to just await, as long we make sure _initialize() never throws\n      yield this.initializePromise;\n      let currentSession = null;\n\n      if (this.persistSession) {\n        const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (maybeSession !== null) {\n          if (this._isValidSession(maybeSession)) {\n            currentSession = maybeSession;\n          } else {\n            yield this._removeSession();\n          }\n        }\n      } else {\n        currentSession = this.inMemorySession;\n      }\n\n      if (!currentSession) {\n        return {\n          data: {\n            session: null\n          },\n          error: null\n        };\n      }\n\n      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n      if (!hasExpired) {\n        return {\n          data: {\n            session: currentSession\n          },\n          error: null\n        };\n      }\n\n      const {\n        session,\n        error\n      } = yield this._callRefreshToken(currentSession.refresh_token);\n\n      if (error) {\n        return {\n          data: {\n            session: null\n          },\n          error\n        };\n      }\n\n      return {\n        data: {\n          session\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n\n\n  getUser(jwt) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!jwt) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n\n          if (error) {\n            throw error;\n          } // Default to Authorization header if there is no existing session\n\n\n          jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n        }\n\n        return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n          headers: this.headers,\n          jwt: jwt,\n          xform: _userResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  updateUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          throw sessionError;\n        }\n\n        if (!sessionData.session) {\n          throw new AuthSessionMissingError();\n        }\n\n        const session = sessionData.session;\n        const {\n          data,\n          error: userError\n        } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n          headers: this.headers,\n          body: attributes,\n          jwt: session.access_token,\n          xform: _userResponse\n        });\n        if (userError) throw userError;\n        session.user = data.user;\n        yield this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED', session);\n\n        return {\n          data: {\n            user: session.user\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n\n\n  _decodeJWT(jwt) {\n    return decodeJWTPayload(jwt);\n  }\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n\n\n  setSession(currentSession) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession.access_token || !currentSession.refresh_token) {\n          throw new AuthSessionMissingError();\n        }\n\n        const timeNow = Date.now() / 1000;\n        let expiresAt = timeNow;\n        let hasExpired = true;\n        let session = null;\n        const payload = decodeJWTPayload(currentSession.access_token);\n\n        if (payload.exp) {\n          expiresAt = payload.exp;\n          hasExpired = expiresAt <= timeNow;\n        }\n\n        if (hasExpired) {\n          const {\n            session: refreshedSession,\n            error\n          } = yield this._callRefreshToken(currentSession.refresh_token);\n\n          if (error) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: error\n            };\n          }\n\n          if (!refreshedSession) {\n            return {\n              data: {\n                user: null,\n                session: null\n              },\n              error: null\n            };\n          }\n\n          session = refreshedSession;\n        } else {\n          const {\n            data,\n            error\n          } = yield this.getUser(currentSession.access_token);\n\n          if (error) {\n            throw error;\n          }\n\n          session = {\n            access_token: currentSession.access_token,\n            refresh_token: currentSession.refresh_token,\n            user: data.user,\n            token_type: 'bearer',\n            expires_in: expiresAt - timeNow,\n            expires_at: expiresAt\n          };\n          yield this._saveSession(session);\n        }\n\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n\n\n  refreshSession(currentSession) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!currentSession) {\n          const {\n            data,\n            error\n          } = yield this.getSession();\n\n          if (error) {\n            throw error;\n          }\n\n          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n        }\n\n        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n          throw new AuthSessionMissingError();\n        }\n\n        const {\n          session,\n          error\n        } = yield this._callRefreshToken(currentSession.refresh_token);\n\n        if (error) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: error\n          };\n        }\n\n        if (!session) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error: null\n          };\n        }\n\n        return {\n          data: {\n            user: session.user,\n            session\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              user: null,\n              session: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Gets the session data from a URL string\n   */\n\n\n  _getSessionFromUrl() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n        if (!this._isImplicitGrantFlow()) {\n          throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n        }\n\n        const error_description = getParameterByName('error_description');\n\n        if (error_description) {\n          const error_code = getParameterByName('error_code');\n          if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.');\n          const error = getParameterByName('error');\n          if (!error) throw new AuthImplicitGrantRedirectError('No error detected.');\n          throw new AuthImplicitGrantRedirectError(error_description, {\n            error,\n            code: error_code\n          });\n        }\n\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          data,\n          error\n        } = yield this.getUser(access_token);\n        if (error) throw error;\n        const user = data.user;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user\n        };\n        const redirectType = getParameterByName('type'); // Remove tokens from URL\n\n        window.location.hash = '';\n        return {\n          data: {\n            session,\n            redirectType\n          },\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              redirectType: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n\n\n  _isImplicitGrantFlow() {\n    return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data,\n        error: sessionError\n      } = yield this.getSession();\n\n      if (sessionError) {\n        return {\n          error: sessionError\n        };\n      }\n\n      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.admin.signOut(accessToken);\n\n        if (error) {\n          // ignore 404s since user might not exist anymore\n          // ignore 401s since an invalid or expired JWT should sign out the current session\n          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n            return {\n              error\n            };\n          }\n        }\n      }\n\n      yield this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT', null);\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n\n\n  onAuthStateChange(callback) {\n    const id = uuid();\n    const subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id);\n      }\n    };\n    this.stateChangeEmitters.set(id, subscription);\n    return {\n      data: {\n        subscription\n      }\n    };\n  }\n  /**\n   * Sends a password reset request to an email address.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n\n\n  resetPasswordForEmail(email, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n          body: {\n            email,\n            gotrue_meta_security: {\n              captcha_token: options.captchaToken\n            }\n          },\n          headers: this.headers,\n          redirectTo: options.redirectTo\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n\n\n  _refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n          body: {\n            refresh_token: refreshToken\n          },\n          headers: this.headers,\n          xform: _sessionResponse\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: {\n              session: null,\n              user: null\n            },\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n\n  _isValidSession(maybeSession) {\n    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n    return isValidSession;\n  }\n\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    }); // try to open on the browser\n\n\n    if (isBrowser()) {\n      window.location.href = url;\n    }\n\n    return {\n      data: {\n        provider,\n        url\n      },\n      error: null\n    };\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const currentSession = yield getItemAsync(this.storage, this.storageKey);\n\n        if (!this._isValidSession(currentSession)) {\n          if (currentSession !== null) {\n            yield this._removeSession();\n          }\n\n          return;\n        }\n\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n\n              if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return;\n              }\n\n              yield this._removeSession();\n            }\n\n            this.networkRetries = 0;\n          } else {\n            yield this._removeSession();\n          }\n        } else {\n          if (this.persistSession) {\n            yield this._saveSession(currentSession);\n          }\n\n          this._notifyAllSubscribers('SIGNED_IN', currentSession);\n        }\n      } catch (err) {\n        console.error(err);\n        return;\n      }\n    });\n  }\n\n  _callRefreshToken(refreshToken) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      // refreshing is already in progress\n      if (this.refreshingDeferred) {\n        return this.refreshingDeferred.promise;\n      }\n\n      try {\n        this.refreshingDeferred = new Deferred();\n\n        if (!refreshToken) {\n          throw new AuthSessionMissingError();\n        }\n\n        const {\n          data,\n          error\n        } = yield this._refreshAccessToken(refreshToken);\n        if (error) throw error;\n        if (!data.session) throw new AuthSessionMissingError();\n        yield this._saveSession(data.session);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n        const result = {\n          session: data.session,\n          error: null\n        };\n        this.refreshingDeferred.resolve(result);\n        return result;\n      } catch (error) {\n        if (isAuthError(error)) {\n          const result = {\n            session: null,\n            error\n          };\n          (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n          return result;\n        }\n\n        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n        throw error;\n      } finally {\n        this.refreshingDeferred = null;\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event, session) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, session));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.persistSession) {\n        this.inMemorySession = session;\n      }\n\n      const expiresAt = session.expires_at;\n\n      if (expiresAt) {\n        const timeNow = Math.round(Date.now() / 1000);\n        const expiresIn = expiresAt - timeNow;\n        const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n      }\n\n      if (this.persistSession && session.expires_at) {\n        yield this._persistSession(session);\n      }\n    });\n  }\n\n  _persistSession(currentSession) {\n    return setItemAsync(this.storage, this.storageKey, currentSession);\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.persistSession) {\n        yield removeItemAsync(this.storage, this.storageKey);\n      } else {\n        this.inMemorySession = null;\n      }\n\n      if (this.refreshTokenTimer) {\n        clearTimeout(this.refreshTokenTimer);\n      }\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds.\n   * @param session The current session.\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n\n      if (!sessionError && session) {\n        const {\n          error\n        } = yield this._callRefreshToken(session.refresh_token);\n        if (!error) this.networkRetries = 0;\n        if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n      }\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n\n  _handleVisibilityChange() {\n    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => __awaiter(this, void 0, void 0, function* () {\n        if (document.visibilityState === 'visible') {\n          yield this.initializePromise;\n          yield this._recoverAndRefresh();\n        }\n      }));\n    } catch (error) {\n      console.error('_handleVisibilityChange', error);\n    }\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n\n\n  _getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(query.toString());\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n\n  _unenroll(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Enrolls a factor\n   * @param friendlyName Human readable name assigned to a device\n   * @param factorType device which we're validating against. Can only be TOTP for now.\n   * @param issuer domain which the user is enrolling with\n   */\n\n\n  _enroll(params) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n          body: {\n            friendly_name: params.friendlyName,\n            factor_type: params.factorType,\n            issuer: params.issuer\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n        }\n\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Validates a device as part of the enrollment step.\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n\n\n  _verify(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        const {\n          data,\n          error\n        } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n          body: {\n            code: params.code,\n            challenge_id: params.challengeId\n          },\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n\n        if (error) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        yield this._saveSession(Object.assign({\n          expires_at: Math.round(Date.now() / 1000) + data.expires_in\n        }, data));\n\n        this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n\n        return {\n          data,\n          error\n        };\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Creates a challenge which a user can verify against\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   */\n\n\n  _challenge(params) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data: sessionData,\n          error: sessionError\n        } = yield this.getSession();\n\n        if (sessionError) {\n          return {\n            data: null,\n            error: sessionError\n          };\n        }\n\n        return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n          headers: this.headers,\n          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n        });\n      } catch (error) {\n        if (isAuthError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n\n        throw error;\n      }\n    });\n  }\n  /**\n   * Creates a challenge and immediately verifies it\n   * @param factorId System assigned identifier for authenticator device as returned by enroll\n   * @param code Code Generated by an authenticator device\n   */\n\n\n  _challengeAndVerify(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: challengeData,\n        error: challengeError\n      } = yield this._challenge({\n        factorId: params.factorId\n      });\n\n      if (challengeError) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n\n      return yield this._verify({\n        factorId: params.factorId,\n        challengeId: challengeData.id,\n        code: params.code\n      });\n    });\n  }\n  /**\n   * Displays all devices for a given user\n   */\n\n\n  _listFactors() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          user\n        },\n        error: userError\n      } = yield this.getUser();\n\n      if (userError) {\n        return {\n          data: null,\n          error: userError\n        };\n      }\n\n      const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n      const totp = factors.filter(factor => factor.factor_type === 'totp' && factor.status === 'verified');\n      return {\n        data: {\n          all: factors,\n          totp\n        },\n        error: null\n      };\n    });\n  }\n  /**\n   * Gets the current and next authenticator assurance level (AAL)\n   * and the current authentication methods for the session (AMR)\n   */\n\n\n  _getAuthenticatorAssuranceLevel() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        data: {\n          session\n        },\n        error: sessionError\n      } = yield this.getSession();\n\n      if (sessionError) {\n        return {\n          data: null,\n          error: sessionError\n        };\n      }\n\n      if (!session) {\n        return {\n          data: {\n            currentLevel: null,\n            nextLevel: null,\n            currentAuthenticationMethods: []\n          },\n          error: null\n        };\n      }\n\n      const payload = this._decodeJWT(session.access_token);\n\n      let currentLevel = null;\n\n      if (payload.aal) {\n        currentLevel = payload.aal;\n      }\n\n      let nextLevel = currentLevel;\n      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n\n      if (verifiedFactors.length > 0) {\n        nextLevel = 'aal2';\n      }\n\n      const currentAuthenticationMethods = payload.amr || [];\n      return {\n        data: {\n          currentLevel,\n          nextLevel,\n          currentAuthenticationMethods\n        },\n        error: null\n      };\n    });\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","NETWORK_FAILURE","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","GoTrueClient","constructor","options","stateChangeEmitters","Map","networkRetries","refreshingDeferred","initializePromise","settings","Object","assign","inMemorySession","storage","admin","fetch","initialize","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","_initialize","_isImplicitGrantFlow","data","error","_getSessionFromUrl","_removeSession","session","redirectType","_saveSession","_notifyAllSubscribers","_recoverAndRefresh","_handleVisibilityChange","signUp","credentials","_a","_b","res","email","password","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","xform","phone","user","signInWithPassword","signInWithOAuth","_c","_handleProviderSignIn","provider","scopes","queryParams","signInWithOtp","_d","create_user","shouldCreateUser","verifyOtp","params","access_token","signInWithSSO","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","getSession","currentSession","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","getUser","jwt","updateUser","attributes","sessionData","sessionError","userError","_decodeJWT","setSession","timeNow","expiresAt","payload","exp","refreshedSession","token_type","expires_in","refreshSession","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","window","location","hash","Boolean","signOut","accessToken","status","onAuthStateChange","callback","id","subscription","unsubscribe","delete","set","resetPasswordForEmail","_refreshAccessToken","refreshToken","isValidSession","_getUrlForProvider","href","Infinity","console","log","message","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","pow","RETRY_INTERVAL","err","promise","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","unref","addEventListener","document","visibilityState","urlParams","encodeURIComponent","push","query","URLSearchParams","toString","join","factorId","friendly_name","friendlyName","factor_type","factorType","issuer","totp","qr_code","challenge_id","challengeId","challengeData","challengeError","factors","filter","factor","all","currentLevel","nextLevel","currentAuthenticationMethods","aal","verifiedFactors","length","amr"],"sources":["/home/runner/Usrmgmt/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, NETWORK_FAILURE, STORAGE_KEY, } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthApiError, isAuthError, } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    storageKey: STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: DEFAULT_HEADERS,\n};\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        this.networkRetries = 0;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the the auth state is known and it's save to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */\n        this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.inMemorySession = null;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.storage = settings.storage || localStorageAdapter;\n        this.admin = new GoTrueAdminApi({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch,\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = resolveFetch(settings.fetch);\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.initialize();\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n        };\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */\n    initialize() {\n        if (!this.initializePromise) {\n            this.initializePromise = this._initialize();\n        }\n        return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n    _initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.initializePromise) {\n                return this.initializePromise;\n            }\n            try {\n                if (this.detectSessionInUrl && this._isImplicitGrantFlow()) {\n                    const { data, error } = yield this._getSessionFromUrl();\n                    if (error) {\n                        // failed login attempt via url,\n                        // remove old session as in verifyOtp, signUp and signInWith*\n                        yield this._removeSession();\n                        return { error };\n                    }\n                    const { session, redirectType } = data;\n                    yield this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                    if (redirectType === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                    }\n                    return { error: null };\n                }\n                // no login attempt via callback url try to recover session from storage\n                yield this._recoverAndRefresh();\n                return { error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { error };\n                }\n                return {\n                    error: new AuthUnknownError('Unexpected error during initialization', error),\n                };\n            }\n            finally {\n                this._handleVisibilityChange();\n            }\n        });\n    }\n    /**\n     * Creates a new user.\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    signUp(credentials) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                let res;\n                if ('email' in credentials) {\n                    const { email, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n                        headers: this.headers,\n                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                        body: {\n                            email,\n                            password,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else if ('phone' in credentials) {\n                    const { phone, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/signup`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            password,\n                            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else {\n                    throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n                }\n                const { data, error } = res;\n                if (error || !data) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                const session = data.session;\n                const user = data.user;\n                if (data.session) {\n                    yield this._saveSession(data.session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     */\n    signInWithPassword(credentials) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                let res;\n                if ('email' in credentials) {\n                    const { email, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                        headers: this.headers,\n                        body: {\n                            email,\n                            password,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else if ('phone' in credentials) {\n                    const { phone, password, options } = credentials;\n                    res = yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            password,\n                            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        xform: _sessionResponse,\n                    });\n                }\n                else {\n                    throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n                }\n                const { data, error } = res;\n                if (error || !data)\n                    return { data: { user: null, session: null }, error };\n                if (data.session) {\n                    yield this._saveSession(data.session);\n                    this._notifyAllSubscribers('SIGNED_IN', data.session);\n                }\n                return { data, error };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n    signInWithOAuth(credentials) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._removeSession();\n            return this._handleProviderSignIn(credentials.provider, {\n                redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            });\n        });\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     */\n    signInWithOtp(credentials) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                if ('email' in credentials) {\n                    const { email, options } = credentials;\n                    const { error } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n                        headers: this.headers,\n                        body: {\n                            email,\n                            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                        redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    });\n                    return { data: { user: null, session: null }, error };\n                }\n                if ('phone' in credentials) {\n                    const { phone, options } = credentials;\n                    const { error } = yield _request(this.fetch, 'POST', `${this.url}/otp`, {\n                        headers: this.headers,\n                        body: {\n                            phone,\n                            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        },\n                    });\n                    return { data: { user: null, session: null }, error };\n                }\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n    verifyOtp(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/verify`, {\n                    headers: this.headers,\n                    body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken } }),\n                    redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                    xform: _sessionResponse,\n                });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                const session = data.session;\n                const user = data.user;\n                if (session === null || session === void 0 ? void 0 : session.access_token) {\n                    yield this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN', session);\n                }\n                return { data: { user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     *\n     * This API is experimental and availability is conditional on correct\n     * settings on the Auth service.\n     *\n     * @experimental\n     */\n    signInWithSSO(params) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this._removeSession();\n                return yield _request(this.fetch, 'POST', `${this.url}/sso`, {\n                    body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ('providerId' in params ? { provider_id: params.providerId } : null)), ('domain' in params ? { domain: params.domain } : null)), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined }), (((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken)\n                        ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n                        : null)), { skip_http_redirect: true }),\n                    headers: this.headers,\n                    xform: _ssoResponse,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n    getSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // make sure we've read the session from the url if there is one\n            // save to just await, as long we make sure _initialize() never throws\n            yield this.initializePromise;\n            let currentSession = null;\n            if (this.persistSession) {\n                const maybeSession = yield getItemAsync(this.storage, this.storageKey);\n                if (maybeSession !== null) {\n                    if (this._isValidSession(maybeSession)) {\n                        currentSession = maybeSession;\n                    }\n                    else {\n                        yield this._removeSession();\n                    }\n                }\n            }\n            else {\n                currentSession = this.inMemorySession;\n            }\n            if (!currentSession) {\n                return { data: { session: null }, error: null };\n            }\n            const hasExpired = currentSession.expires_at\n                ? currentSession.expires_at <= Date.now() / 1000\n                : false;\n            if (!hasExpired) {\n                return { data: { session: currentSession }, error: null };\n            }\n            const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return { data: { session: null }, error };\n            }\n            return { data: { session }, error: null };\n        });\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n    getUser(jwt) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!jwt) {\n                    const { data, error } = yield this.getSession();\n                    if (error) {\n                        throw error;\n                    }\n                    // Default to Authorization header if there is no existing session\n                    jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n                }\n                return yield _request(this.fetch, 'GET', `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _userResponse,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    updateUser(attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                const { data, error: userError } = yield _request(this.fetch, 'PUT', `${this.url}/user`, {\n                    headers: this.headers,\n                    body: attributes,\n                    jwt: session.access_token,\n                    xform: _userResponse,\n                });\n                if (userError)\n                    throw userError;\n                session.user = data.user;\n                yield this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED', session);\n                return { data: { user: session.user }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n    _decodeJWT(jwt) {\n        return decodeJWTPayload(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n    setSession(currentSession) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!currentSession.access_token || !currentSession.refresh_token) {\n                    throw new AuthSessionMissingError();\n                }\n                const timeNow = Date.now() / 1000;\n                let expiresAt = timeNow;\n                let hasExpired = true;\n                let session = null;\n                const payload = decodeJWTPayload(currentSession.access_token);\n                if (payload.exp) {\n                    expiresAt = payload.exp;\n                    hasExpired = expiresAt <= timeNow;\n                }\n                if (hasExpired) {\n                    const { session: refreshedSession, error } = yield this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        return { data: { user: null, session: null }, error: error };\n                    }\n                    if (!refreshedSession) {\n                        return { data: { user: null, session: null }, error: null };\n                    }\n                    session = refreshedSession;\n                }\n                else {\n                    const { data, error } = yield this.getUser(currentSession.access_token);\n                    if (error) {\n                        throw error;\n                    }\n                    session = {\n                        access_token: currentSession.access_token,\n                        refresh_token: currentSession.refresh_token,\n                        user: data.user,\n                        token_type: 'bearer',\n                        expires_in: expiresAt - timeNow,\n                        expires_at: expiresAt,\n                    };\n                    yield this._saveSession(session);\n                }\n                return { data: { user: session.user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n    refreshSession(currentSession) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!currentSession) {\n                    const { data, error } = yield this.getSession();\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new AuthSessionMissingError();\n                }\n                const { session, error } = yield this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                if (!session) {\n                    return { data: { user: null, session: null }, error: null };\n                }\n                return { data: { user: session.user, session }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n    _getSessionFromUrl() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new AuthImplicitGrantRedirectError('No browser detected.');\n                if (!this._isImplicitGrantFlow()) {\n                    throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n                }\n                const error_description = getParameterByName('error_description');\n                if (error_description) {\n                    const error_code = getParameterByName('error_code');\n                    if (!error_code)\n                        throw new AuthImplicitGrantRedirectError('No error_code detected.');\n                    const error = getParameterByName('error');\n                    if (!error)\n                        throw new AuthImplicitGrantRedirectError('No error detected.');\n                    throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code });\n                }\n                const provider_token = getParameterByName('provider_token');\n                const provider_refresh_token = getParameterByName('provider_refresh_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new AuthImplicitGrantRedirectError('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new AuthImplicitGrantRedirectError('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { data, error } = yield this.getUser(access_token);\n                if (error)\n                    throw error;\n                const user = data.user;\n                const session = {\n                    provider_token,\n                    provider_refresh_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user,\n                };\n                const redirectType = getParameterByName('type');\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: { session, redirectType }, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, redirectType: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n    _isImplicitGrantFlow() {\n        return (isBrowser() &&\n            (Boolean(getParameterByName('access_token')) ||\n                Boolean(getParameterByName('error_description'))));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data, error: sessionError } = yield this.getSession();\n            if (sessionError) {\n                return { error: sessionError };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = yield this.admin.signOut(accessToken);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n                        return { error };\n                    }\n                }\n            }\n            yield this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT', null);\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n    onAuthStateChange(callback) {\n        const id = uuid();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: () => {\n                this.stateChangeEmitters.delete(id);\n            },\n        };\n        this.stateChangeEmitters.set(id, subscription);\n        return { data: { subscription } };\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n    resetPasswordForEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield _request(this.fetch, 'POST', `${this.url}/recover`, {\n                    body: { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n                    headers: this.headers,\n                    redirectTo: options.redirectTo,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    _refreshAccessToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n                    body: { refresh_token: refreshToken },\n                    headers: this.headers,\n                    xform: _sessionResponse,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: { session: null, user: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === 'object' &&\n            maybeSession !== null &&\n            'access_token' in maybeSession &&\n            'refresh_token' in maybeSession &&\n            'expires_at' in maybeSession;\n        return isValidSession;\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this._getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams,\n        });\n        // try to open on the browser\n        if (isBrowser()) {\n            window.location.href = url;\n        }\n        return { data: { provider, url }, error: null };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const currentSession = yield getItemAsync(this.storage, this.storageKey);\n                if (!this._isValidSession(currentSession)) {\n                    if (currentSession !== null) {\n                        yield this._removeSession();\n                    }\n                    return;\n                }\n                const timeNow = Math.round(Date.now() / 1000);\n                if (((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        this.networkRetries++;\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            if (error instanceof AuthRetryableFetchError &&\n                                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                                if (this.refreshTokenTimer)\n                                    clearTimeout(this.refreshTokenTimer);\n                                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                                );\n                                return;\n                            }\n                            yield this._removeSession();\n                        }\n                        this.networkRetries = 0;\n                    }\n                    else {\n                        yield this._removeSession();\n                    }\n                }\n                else {\n                    if (this.persistSession) {\n                        yield this._saveSession(currentSession);\n                    }\n                    this._notifyAllSubscribers('SIGNED_IN', currentSession);\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return;\n            }\n        });\n    }\n    _callRefreshToken(refreshToken) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            // refreshing is already in progress\n            if (this.refreshingDeferred) {\n                return this.refreshingDeferred.promise;\n            }\n            try {\n                this.refreshingDeferred = new Deferred();\n                if (!refreshToken) {\n                    throw new AuthSessionMissingError();\n                }\n                const { data, error } = yield this._refreshAccessToken(refreshToken);\n                if (error)\n                    throw error;\n                if (!data.session)\n                    throw new AuthSessionMissingError();\n                yield this._saveSession(data.session);\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n                const result = { session: data.session, error: null };\n                this.refreshingDeferred.resolve(result);\n                return result;\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    const result = { session: null, error };\n                    (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                    return result;\n                }\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n                throw error;\n            }\n            finally {\n                this.refreshingDeferred = null;\n            }\n        });\n    }\n    _notifyAllSubscribers(event, session) {\n        this.stateChangeEmitters.forEach((x) => x.callback(event, session));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.persistSession) {\n                this.inMemorySession = session;\n            }\n            const expiresAt = session.expires_at;\n            if (expiresAt) {\n                const timeNow = Math.round(Date.now() / 1000);\n                const expiresIn = expiresAt - timeNow;\n                const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n                this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n            }\n            if (this.persistSession && session.expires_at) {\n                yield this._persistSession(session);\n            }\n        });\n    }\n    _persistSession(currentSession) {\n        return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.persistSession) {\n                yield removeItemAsync(this.storage, this.storageKey);\n            }\n            else {\n                this.inMemorySession = null;\n            }\n            if (this.refreshTokenTimer) {\n                clearTimeout(this.refreshTokenTimer);\n            }\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds.\n     * @param session The current session.\n     */\n    _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer)\n            clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken)\n            return;\n        this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            this.networkRetries++;\n            const { data: { session }, error: sessionError, } = yield this.getSession();\n            if (!sessionError && session) {\n                const { error } = yield this._callRefreshToken(session.refresh_token);\n                if (!error)\n                    this.networkRetries = 0;\n                if (error instanceof AuthRetryableFetchError &&\n                    this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)\n                    this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n            }\n        }), value);\n        if (typeof this.refreshTokenTimer.unref === 'function')\n            this.refreshTokenTimer.unref();\n    }\n    _handleVisibilityChange() {\n        if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => __awaiter(this, void 0, void 0, function* () {\n                if (document.visibilityState === 'visible') {\n                    yield this.initializePromise;\n                    yield this._recoverAndRefresh();\n                }\n            }));\n        }\n        catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n    _getUrlForProvider(provider, options) {\n        const urlParams = [`provider=${encodeURIComponent(provider)}`];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        return `${this.url}/authorize?${urlParams.join('&')}`;\n    }\n    _unenroll(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return yield _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Enrolls a factor\n     * @param friendlyName Human readable name assigned to a device\n     * @param factorType device which we're validating against. Can only be TOTP for now.\n     * @param issuer domain which the user is enrolling with\n     */\n    _enroll(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/factors`, {\n                    body: {\n                        friendly_name: params.friendlyName,\n                        factor_type: params.factorType,\n                        issuer: params.issuer,\n                    },\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n                if (error) {\n                    return { data: null, error };\n                }\n                if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Validates a device as part of the enrollment step.\n     * @param factorId System assigned identifier for authenticator device as returned by enroll\n     * @param code Code Generated by an authenticator device\n     */\n    _verify(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const { data, error } = yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n                    body: { code: params.code, challenge_id: params.challengeId },\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n                if (error) {\n                    return { data: null, error };\n                }\n                yield this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1000) + data.expires_in }, data));\n                this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n                return { data, error };\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a challenge which a user can verify against\n     * @param factorId System assigned identifier for authenticator device as returned by enroll\n     */\n    _challenge(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data: sessionData, error: sessionError } = yield this.getSession();\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return yield _request(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            }\n            catch (error) {\n                if (isAuthError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a challenge and immediately verifies it\n     * @param factorId System assigned identifier for authenticator device as returned by enroll\n     * @param code Code Generated by an authenticator device\n     */\n    _challengeAndVerify(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: challengeData, error: challengeError } = yield this._challenge({\n                factorId: params.factorId,\n            });\n            if (challengeError) {\n                return { data: null, error: challengeError };\n            }\n            return yield this._verify({\n                factorId: params.factorId,\n                challengeId: challengeData.id,\n                code: params.code,\n            });\n        });\n    }\n    /**\n     * Displays all devices for a given user\n     */\n    _listFactors() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: { user }, error: userError, } = yield this.getUser();\n            if (userError) {\n                return { data: null, error: userError };\n            }\n            const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n            const totp = factors.filter((factor) => factor.factor_type === 'totp' && factor.status === 'verified');\n            return {\n                data: {\n                    all: factors,\n                    totp,\n                },\n                error: null,\n            };\n        });\n    }\n    /**\n     * Gets the current and next authenticator assurance level (AAL)\n     * and the current authentication methods for the session (AMR)\n     */\n    _getAuthenticatorAssuranceLevel() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data: { session }, error: sessionError, } = yield this.getSession();\n            if (sessionError) {\n                return { data: null, error: sessionError };\n            }\n            if (!session) {\n                return {\n                    data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n                    error: null,\n                };\n            }\n            const payload = this._decodeJWT(session.access_token);\n            let currentLevel = null;\n            if (payload.aal) {\n                currentLevel = payload.aal;\n            }\n            let nextLevel = currentLevel;\n            const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n            if (verifiedFactors.length > 0) {\n                nextLevel = 'aal2';\n            }\n            const currentAuthenticationMethods = payload.amr || [];\n            return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}